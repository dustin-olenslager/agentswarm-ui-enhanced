<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AgentSwarm 3D Graph</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
  * { margin: 0; padding: 0; }
  body { background: #1a1a20; overflow: hidden; font-family: sans-serif; }
  canvas { display: block; }
  #hud {
    position: absolute; top: 16px; left: 16px; color: #aaa;
    font-size: 12px; font-family: 'JetBrains Mono', monospace;
    pointer-events: none;
  }
  #hud .val { color: #fff; }
</style>
</head>
<body>
<div id="hud">
  <div>workers: <span class="val" id="hud-workers">0</span></div>
  <div>completed: <span class="val" id="hud-completed">0</span></div>
  <div>tokens: <span class="val" id="hud-tokens">0</span></div>
  <div>commits/hr: <span class="val" id="hud-cph">0</span></div>
</div>
<script>
// ─── Graph Data Model (mirrors PlannerTreeState from dashboard.py) ───
const graph = {
  nodes: new Map(),   // id → { id, role, status, parentId, desc, x, y, z, vx, vy, vz }
  edges: [],          // [{ source, target }]
};

const ROLE_COLORS = {
  'root-planner': 0x88ccee,  // light blue (the "pawn" in the screenshot)
  'planner':      0xe8e8a0,  // warm yellow
  'subplanner':   0xe8e8a0,  // warm yellow
  'worker':       0xe8e8a0,  // warm yellow
  'reconciler':   0xff6688,  // pink/red
};

const STATUS_COLORS = {
  'pending':   0x888866,
  'assigned':  0xaaaa55,
  'running':   0xe8e8a0,
  'complete':  0x88ee88,
  'failed':    0xff4466,
  'cancelled': 0x666666,
};

// ─── Three.js Scene Setup ───
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x1a1a20, 0.015);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 500);
camera.position.set(0, 5, 30);
camera.lookAt(0, 0, 0);

const renderer3d = new THREE.WebGLRenderer({ antialias: true });
renderer3d.setSize(innerWidth, innerHeight);
renderer3d.setPixelRatio(devicePixelRatio);
renderer3d.setClearColor(0x1a1a20);
document.body.appendChild(renderer3d.domElement);

// Ambient + point lights for glow effect
scene.add(new THREE.AmbientLight(0x333333));
const pointLight = new THREE.PointLight(0xffffff, 0.8, 100);
pointLight.position.set(0, 10, 10);
scene.add(pointLight);

// Glow sprite texture (radial gradient)
function makeGlowTexture() {
  const c = document.createElement('canvas');
  c.width = c.height = 128;
  const ctx = c.getContext('2d');
  const g = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
  g.addColorStop(0, 'rgba(255,255,255,0.6)');
  g.addColorStop(0.3, 'rgba(255,255,200,0.2)');
  g.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, 128, 128);
  return new THREE.CanvasTexture(c);
}
const glowTex = makeGlowTexture();

// Node meshes group
const nodeGroup = new THREE.Group();
scene.add(nodeGroup);

// Edge lines group
const edgeGroup = new THREE.Group();
scene.add(edgeGroup);

// Label sprites group
const labelGroup = new THREE.Group();
scene.add(labelGroup);

// ─── Node Creation ───
function addNode(id, role, status, parentId, desc) {
  if (graph.nodes.has(id)) {
    const n = graph.nodes.get(id);
    n.status = status;
    n.role = role || n.role;
    // Update mesh color
    if (n.mesh) {
      n.mesh.material.color.setHex(STATUS_COLORS[status] || 0xe8e8a0);
    }
    return n;
  }

  // Position near parent or random
  let x = (Math.random() - 0.5) * 20;
  let y = (Math.random() - 0.5) * 15;
  let z = (Math.random() - 0.5) * 20;

  if (parentId && graph.nodes.has(parentId)) {
    const p = graph.nodes.get(parentId);
    x = p.x + (Math.random() - 0.5) * 6;
    y = p.y + (Math.random() - 0.5) * 4;
    z = p.z + (Math.random() - 0.5) * 6;
  }

  const nodeData = { id, role, status, parentId, desc, x, y, z, vx:0, vy:0, vz:0 };

  // Sphere mesh
  const isRoot = role === 'root-planner';
  const radius = isRoot ? 1.2 : 0.6;
  const geo = new THREE.SphereGeometry(radius, 24, 24);
  const mat = new THREE.MeshStandardMaterial({
    color: STATUS_COLORS[status] || ROLE_COLORS[role] || 0xe8e8a0,
    emissive: STATUS_COLORS[status] || ROLE_COLORS[role] || 0xe8e8a0,
    emissiveIntensity: 0.3,
    roughness: 0.4,
    metalness: 0.1,
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(x, y, z);
  nodeGroup.add(mesh);
  nodeData.mesh = mesh;

  // Glow sprite
  const spriteMat = new THREE.SpriteMaterial({
    map: glowTex,
    color: STATUS_COLORS[status] || ROLE_COLORS[role] || 0xe8e8a0,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  });
  const sprite = new THREE.Sprite(spriteMat);
  sprite.scale.set(radius * 4, radius * 4, 1);
  mesh.add(sprite);
  nodeData.glow = sprite;

  // Label
  if (desc) {
    const label = makeLabel(desc.slice(0, 20));
    label.position.set(x, y + radius + 0.5, z);
    labelGroup.add(label);
    nodeData.label = label;
  }

  graph.nodes.set(id, nodeData);

  // Edge to parent
  if (parentId && graph.nodes.has(parentId)) {
    addEdge(parentId, id);
  }

  return nodeData;
}

function makeLabel(text) {
  const c = document.createElement('canvas');
  c.width = 256; c.height = 64;
  const ctx = c.getContext('2d');
  ctx.font = '18px sans-serif';
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.textAlign = 'center';
  ctx.fillText(text, 128, 36);
  const tex = new THREE.CanvasTexture(c);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthWrite: false });
  const s = new THREE.Sprite(mat);
  s.scale.set(4, 1, 1);
  return s;
}

function addEdge(sourceId, targetId) {
  const mat = new THREE.LineBasicMaterial({ color: 0x555555, transparent: true, opacity: 0.5 });
  const geo = new THREE.BufferGeometry();
  const s = graph.nodes.get(sourceId);
  const t = graph.nodes.get(targetId);
  geo.setFromPoints([
    new THREE.Vector3(s.x, s.y, s.z),
    new THREE.Vector3(t.x, t.y, t.z),
  ]);
  const line = new THREE.Line(geo, mat);
  edgeGroup.add(line);
  graph.edges.push({ source: sourceId, target: targetId, line });
}

// ─── Force-Directed Layout (runs every frame) ───
function simulateForces() {
  const nodes = [...graph.nodes.values()];
  const REPULSION = 8;
  const SPRING = 0.02;
  const REST_LEN = 5;
  const DAMPING = 0.9;
  const CENTER_PULL = 0.002;

  // Repulsion between all nodes
  for (let i = 0; i < nodes.length; i++) {
    for (let j = i + 1; j < nodes.length; j++) {
      const a = nodes[i], b = nodes[j];
      let dx = a.x - b.x, dy = a.y - b.y, dz = a.z - b.z;
      let dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.1;
      let f = REPULSION / (dist * dist);
      a.vx += dx/dist * f; a.vy += dy/dist * f; a.vz += dz/dist * f;
      b.vx -= dx/dist * f; b.vy -= dy/dist * f; b.vz -= dz/dist * f;
    }
  }

  // Spring attraction along edges
  for (const e of graph.edges) {
    const s = graph.nodes.get(e.source), t = graph.nodes.get(e.target);
    if (!s || !t) continue;
    let dx = t.x - s.x, dy = t.y - s.y, dz = t.z - s.z;
    let dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.1;
    let f = SPRING * (dist - REST_LEN);
    s.vx += dx/dist * f; s.vy += dy/dist * f; s.vz += dz/dist * f;
    t.vx -= dx/dist * f; t.vy -= dy/dist * f; t.vz -= dz/dist * f;
  }

  // Center pull + damping + apply
  for (const n of nodes) {
    n.vx -= n.x * CENTER_PULL; n.vy -= n.y * CENTER_PULL; n.vz -= n.z * CENTER_PULL;
    n.vx *= DAMPING; n.vy *= DAMPING; n.vz *= DAMPING;
    n.x += n.vx; n.y += n.vy; n.z += n.vz;
    if (n.mesh) n.mesh.position.set(n.x, n.y, n.z);
    if (n.label) n.label.position.set(n.x, n.y + 1.2, n.z);
  }

  // Update edge geometry
  for (const e of graph.edges) {
    const s = graph.nodes.get(e.source), t = graph.nodes.get(e.target);
    if (!s || !t || !e.line) continue;
    const pos = e.line.geometry.attributes.position;
    pos.setXYZ(0, s.x, s.y, s.z);
    pos.setXYZ(1, t.x, t.y, t.z);
    pos.needsUpdate = true;
  }
}

// ─── NDJSON Event Ingestion (same logic as dashboard.py ingest()) ───
function ingestEvent(event) {
  const msg = event.message || '';
  const data = event.data || {};
  const agentRole = event.agentRole || '';
  const taskId = data.taskId || event.taskId || '';

  // Infer role for node
  function nodeRole() {
    if (agentRole === 'root-planner' && !data.parentId) return 'root-planner';
    if (agentRole === 'subplanner') return 'subplanner';
    if (agentRole === 'worker') return 'worker';
    if (agentRole === 'reconciler') return 'reconciler';
    return 'planner';
  }

  if (msg === 'Task created') {
    addNode(taskId, nodeRole(), 'pending', data.parentId || null, data.desc || taskId);
  }
  else if (msg === 'Task status') {
    const to = data.to || '';
    if (taskId) addNode(taskId, nodeRole(), to, data.parentId || null, '');
  }
  else if (msg === 'Task completed') {
    const status = data.status === 'complete' ? 'complete' : 'failed';
    if (taskId) addNode(taskId, nodeRole(), status, data.parentId || null, '');
  }
  else if (msg === 'Dispatching task to ephemeral sandbox') {
    if (taskId) addNode(taskId, 'worker', 'assigned', data.parentId || null, '');
  }
  else if (msg === 'Subtask still complex — recursing') {
    const sid = data.subtaskId || '';
    if (sid) addNode(sid, 'subplanner', 'running', data.parentId || null, '');
  }
  else if (msg === 'Metrics') {
    document.getElementById('hud-workers').textContent = data.activeWorkers || 0;
    document.getElementById('hud-completed').textContent = data.completedTasks || 0;
    document.getElementById('hud-tokens').textContent = (data.totalTokensUsed || 0).toLocaleString();
    document.getElementById('hud-cph').textContent = (data.commitsPerHour || 0).toFixed(1);
  }
}

// ─── Camera Orbit ───
let angle = 0;
function updateCamera() {
  angle += 0.002;
  camera.position.x = Math.sin(angle) * 30;
  camera.position.z = Math.cos(angle) * 30;
  camera.position.y = 8 + Math.sin(angle * 0.5) * 3;
  camera.lookAt(0, 0, 0);
}

// ─── Render Loop ───
function animate() {
  requestAnimationFrame(animate);
  simulateForces();
  updateCamera();
  renderer3d.render(scene, camera);
}
animate();

// ─── Feed demo data (replace with WebSocket/SSE for live orchestrator) ───
const DEMO_LOG = [
  {"timestamp":1707900000000,"level":"info","agentId":"main","agentRole":"root-planner","message":"Task created","data":{"taskId":"root","parentId":null,"desc":"Root Planner"}},
  {"timestamp":1707900000050,"level":"info","agentId":"main","agentRole":"root-planner","message":"Task status","data":{"taskId":"root","from":"pending","to":"running"}},
  {"timestamp":1707900000100,"level":"info","agentId":"main","agentRole":"root-planner","message":"Task created","data":{"taskId":"agent-001","parentId":"root","desc":"chunk meshing"}},
  {"timestamp":1707900000200,"level":"info","agentId":"main","agentRole":"root-planner","message":"Task created","data":{"taskId":"agent-002","parentId":"root","desc":"WebGL2 renderer"}},
  {"timestamp":1707900000300,"level":"info","agentId":"main","agentRole":"root-planner","message":"Task created","data":{"taskId":"agent-003","parentId":"root","desc":"player controller"}},
  {"timestamp":1707900000400,"level":"info","agentId":"main","agentRole":"root-planner","message":"Task created","data":{"taskId":"agent-004","parentId":"root","desc":"terrain noise"}},
  {"timestamp":1707900001000,"level":"info","agentId":"sub-1","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-001-sub-1","parentId":"agent-001","desc":"face culling"}},
  {"timestamp":1707900001100,"level":"info","agentId":"sub-1","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-001-sub-2","parentId":"agent-001","desc":"greedy mesh"}},
  {"timestamp":1707900001200,"level":"info","agentId":"sub-1","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-001-sub-3","parentId":"agent-001","desc":"chunk LOD"}},
  {"timestamp":1707900001300,"level":"info","agentId":"sub-2","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-002-sub-1","parentId":"agent-002","desc":"shader pipeline"}},
  {"timestamp":1707900001400,"level":"info","agentId":"sub-2","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-002-sub-2","parentId":"agent-002","desc":"texture atlas"}},
  {"timestamp":1707900001500,"level":"info","agentId":"sub-3","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-003-sub-1","parentId":"agent-003","desc":"collision"}},
  {"timestamp":1707900001600,"level":"info","agentId":"sub-3","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-003-sub-2","parentId":"agent-003","desc":"physics"}},
  {"timestamp":1707900001700,"level":"info","agentId":"sub-4","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-004-sub-1","parentId":"agent-004","desc":"perlin noise"}},
  {"timestamp":1707900001800,"level":"info","agentId":"sub-4","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-004-sub-2","parentId":"agent-004","desc":"biome blending"}},
  // Deeper recursion
  {"timestamp":1707900002000,"level":"info","agentId":"sub-5","agentRole":"subplanner","message":"Subtask still complex — recursing","data":{"subtaskId":"agent-001-sub-1-sub-1","parentId":"agent-001-sub-1"}},
  {"timestamp":1707900002100,"level":"info","agentId":"sub-5","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-001-sub-1-sub-1","parentId":"agent-001-sub-1","desc":"cull hidden"}},
  {"timestamp":1707900002200,"level":"info","agentId":"sub-5","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-001-sub-1-sub-2","parentId":"agent-001-sub-1","desc":"AO pass"}},
  {"timestamp":1707900002300,"level":"info","agentId":"sub-6","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-002-sub-1-sub-1","parentId":"agent-002-sub-1","desc":"vertex shader"}},
  {"timestamp":1707900002400,"level":"info","agentId":"sub-6","agentRole":"subplanner","message":"Task created","data":{"taskId":"agent-002-sub-1-sub-2","parentId":"agent-002-sub-1","desc":"frag shader"}},
  // Workers dispatched
  {"timestamp":1707900003000,"level":"info","agentId":"worker-pool","agentRole":"root-planner","message":"Dispatching task to ephemeral sandbox","data":{"taskId":"agent-001-sub-1-sub-1"}},
  {"timestamp":1707900003000,"level":"info","agentId":"main","agentRole":"root-planner","message":"Task status","data":{"taskId":"agent-001-sub-1-sub-1","from":"pending","to":"running"}},
  {"timestamp":1707900003100,"level":"info","agentId":"worker-pool","agentRole":"root-planner","message":"Dispatching task to ephemeral sandbox","data":{"taskId":"agent-002-sub-1-sub-1"}},
  {"timestamp":1707900003100,"level":"info","agentId":"main","agentRole":"root-planner","message":"Task status","data":{"taskId":"agent-002-sub-1-sub-1","from":"pending","to":"running"}},
  // Completions
  {"timestamp":1707900005000,"level":"info","agentId":"main","agentRole":"root-planner","message":"Task completed","data":{"taskId":"agent-001-sub-1-sub-1","status":"complete"}},
  {"timestamp":1707900005500,"level":"info","agentId":"main","agentRole":"root-planner","message":"Task completed","data":{"taskId":"agent-002-sub-1-sub-1","status":"complete"}},
  // A failure (turns pink like in the screenshot)
  {"timestamp":1707900006000,"level":"info","agentId":"main","agentRole":"root-planner","message":"Task completed","data":{"taskId":"agent-004-sub-1","status":"failed"}},
  // Metrics
  {"timestamp":1707900008000,"level":"info","agentId":"monitor","agentRole":"root-planner","message":"Metrics","data":{"activeWorkers":8,"pendingTasks":5,"completedTasks":12,"failedTasks":1,"commitsPerHour":42.5,"mergeSuccessRate":0.94,"totalTokensUsed":125000}},
  // Reconciler
  {"timestamp":1707900009000,"level":"info","agentId":"reconciler","agentRole":"reconciler","message":"Task created","data":{"taskId":"reconciler-fix-1","parentId":"root","desc":"fix/tsc/compile-grid"}},
];

// Replay demo events with timing
let idx = 0;
function replayNext() {
  if (idx >= DEMO_LOG.length) return;
  ingestEvent(DEMO_LOG[idx]);
  idx++;
  setTimeout(replayNext, 150 + Math.random() * 200);
}
replayNext();
</script>
</body>
</html>
